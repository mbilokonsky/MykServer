<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<title>"Skai for Node Documentation"</title>
<style type="text/css">
body {
	background-color:#000;
	color:#eee;
}
#wrapper {
	width:1000px;
	margin:0 auto;
}
.content {
	margin-top:20px;
	background-color: #333;
	padding:10px;
}
</style>
</head>
<body>
<div id="wrapper">
  <h1>Documentation for the Skai library for node.js</h1>
  <div id="introduction" class="content">
    <p>This document will explain the various API methods available for use with the skai library for Node.js. All of the information contained herein is subject to change as this is an ongoing process, but this should be sufficient to get started.</p>
    <p>As soon as we publish this library to NPM (the Node Package Manager) it'll be trivially easy to install it by typing "npm install skai" on the command line. For now, however, the only way to get the library is via a zipped file from myk. Once you have the folder, make sure that node.js is installed on your system and do the following:</p>
    <ul>
      <li>create a directory in your home directory called SkaiSample, and switch to that directory.</li>
      <li>within ~/SkaiSample, create a folder called "node_modules"</li>
      <li>copy the "skai" folder into the "~/SkaiSample/node_modules" folder</li>
      <li>create a file in ~/SkaiSample called "app.js"</li>
      <li>Open "app.js" in your favorite text editor.</li>
    </ul>
  </div>
  <div id="gettingStarted" class="content">
    <h2>Getting Started</h2>
    <p>This library is designed to allow you to interact with a remote instance of the platform from a concise and easy to use JavaScript object. You must instantiate the skai library within your javascript project as follows:</p>
    <pre>var skai = require("skai").Begin("123.456.789.100", "8080")</pre>
    <p>The two arguments you pass into the initializer method are the url and the port for the instance of the Skai platform you'd like to interact with. If you simply call "Begin()" it'll assume you want localhost:8080. This method creates a new instance of the platform that uses the provided host and port as the basis for all outbound HTTP posts associated with the various methods.</p>
    <p>Once you have your skai object, you can start doing stuff. Before diving into the specific API methods, let's discuss the architecture of this library.</p>
  </div>
  <div id="architecture" class="content">
    <h2>Architecture</h2>
    <p>The Skai library for node defines a small set of specific objects:</p>
    <ul>
      <li>
        <pre>Skai</pre>
        - the Skai object is the wrapper for everything. When you call Skai.Begin() it instantiates the Skai object and you can call all API methods.</li>
      <li>
        <pre>Entity</pre>
        - this is used to represent every entity in the database (including forms and relationships). All skai properties on the entity have special accessors (using PropertyCollections) that generate Delta objects when they are changed - this means that you can work with the Entity as though it were a regular JS object, but then commit it to the platform and have all of its changes logged. The Entity object has the following signature:
        <pre>Entity(name, guid, timestamp, formGuid, propertyNames)</pre>
        , and all strings in the "propertyNames" array get materialized in terms of the accessors discussed above.</li>
      <li>
        <pre>PropertyCollection</pre>
        - This should be completely invisible to users of this library, but I'm including it for completion. The PropertyCollection is like an array, but all mutator methods are overridden to generate Delta objects. This means that if I say myEntity.myProperty.push(foo), that "push()" method as implemented in the "myProperty" PropertyCollection will automatically create a Delta and store it on the entity.</li>
      <li>
        <pre>Delta</pre>
        - Not to be confused with an actual Skai Delta (aka a Relationship), the Skai for Node Delta is a very similar serialization mechanism used to capture changes to Entities. The Delta Constructor has the following signature:
        <pre>Delta(entityGuid, propertyName, values, type)</pre>
        , where the entityGuid argument is the guid of the entity which has changed, the propertyName is the property that has changed, the values are the values that are being either "INSERT"ed, "REMOVE"d or "SET", and type is either "INSERT", "REMOVE" or "SET". Each Delta object also has a nice getFormattedValue() function which returns a DSL string for processing on the platform.</li>
      <li>
        <pre>LocalIndex</pre>
        - This is used to allow local interaction with data. All entities coming into the system are stored here and indexed both by name and by guid. The current implementation lets LocalIndex listen for events on the Skai object to determine when a new entity has arrived, and then index it automatically.</li>
      <li>
        <pre>Endpoint</pre>
        - Finally, the Endpoint object is what handles the actual communication between the node.js application and the remote skai server. Currently the only endpoint we have is the HTTP endpoint - but in theory a TCP endpoint or Hook.io endpoint should also be fairly simple to create. By encapsulating connectivity we give ourselves a pluggable mechanism here to support any transport protocol we want down the line.</li>
    </ul>
    <p>Now that we understand how the underlying architecture works in general, let's dig into the specifics. First we'll discuss remote operations using the Skai object. Then we'll take a look at local operations which make use of the LocalIndex, and finally we'll look at object manipulation using the Entity object.</p>
  </div>
  <div id="remoteMethods" class="content">
    <h2>Remote Methods</h2>
    <p>The remote access part of library is designed as a wrapper for a set of HTTP Posts. These posts are actually fully implemented in the HTTPEndpoint that we're using, but that could actually be replaced by some other messaging protocol later if we wanted it to be. </p>
    <p>The most basic of the remote methods is "query" - it simply takes whatever text you submit and acts as a passthrough, sending that text directly to the platform DSL interpreter. Other methods simply populate the correct DSL expression with the values you provide, so that the user never has to actually work with the DSL if he doesn't want to.</p>
    <p>What follows is a list of all remote methods and their signatures, with some commentary. Note that each of these methods takes an optional "callback" argument - this is a function that you provide which will be called when the operation completes. The values that are "returned" by these methods are not actually "returned" in a syncronous way - rather, when one of these methods "returns" a value what that means is that it executes the callback method you provided, and passes its return value into that callback as an argument.</p>
    <ul>
      <li>
        <pre>skai.query(queryString, callback)</pre>
        - this is the most fundamental method. Whatever query string you pass in will be treated as a straight DSL entry into the platform. All other remote API methods in the system can be replicated using skai.query, so in a pinch this is really everything.</li>
      <li>
        <pre>skai.getEntities(guidCollection, callback)</pre>
        - this takes an array of one or more guids, and it "returns" an array of entities. Note that this will ALWAYS return an Array - even if it's only of length one, it will be an array. Note that the transport mechanism used by the platform sends us JSON with entity information, but construction of local Entity objects actually takes place in Node. We'll get to that soon. <strong>The entities that you get back will be automatically indexed even if you do not provide a callback function!</strong></li>
      <li>
        <pre>skai.getEntityProperty(entityGuid, propertyName, callback)</pre>
        - "returns" an array containing the current values of the specified entity at the specified property.</li>
      <li>
        <pre>skai.delete(entityGuid, callback)</pre>
        - this should remove the entity specified, but is not currently functioning.</li>
      <li>
        <pre>skai.createForm(formName, propertyList, callback)</pre>
        - this method allows you to create a new form. Right now this is a little bit buggy - it's very slow, and it is lacking important functionality such as the ability to extend an existing form or reuse existing properties. But, it works for now, and the current changes being made to the platform will address these problems. "propertyList" is just an array of strings, each one naming one property you'd like to see on this form. <strong>The form that you create will be automatically indexed even if you do not provide a callback function!</strong></li>
      <li>
        <pre>skai.createEntity(entityName, formGuid, callback)</pre>
        - this will ask the server to instantiate the form guid you're providing, and assign the provided name to the resulting Entity. It then "returns" that entity. <strong>The entity that you create will be automatically indexed even if you do not provide a callback function!</strong></li>
      <li>
        <pre>skai.commitEntity(entity)</pre>
        - this will extract all Deltas from the provided entity and submit them to the platform for persistence. You must manually call skai.commitEntity(yourEntity) if you want your changes to be saved!</li>
    </ul>
    <p>This small handful of methods is all you need to interact with the server. Honestly I may remove "getEntityProperty" since that's really just duplicating effort - you could just get the entity, then read the property. But, maybe I'll keep it because that way you can get a value without indexing the entity locally. I go back and forth.</p>
  </div>
  <div id="localIndexing" class="content">
    <h2>Local Indexing</h2>
    <p>Let's take a quick moment to talk about indexing and events. There are certain method calls above where I've pointed out in bold that results will be indexed automatically. What does that mean exactly? It means that when JSON-serialized information comes back from the platform, it gets pre-processed by means of a private method within the skai object. This method acts as a factory which takes deserialized JSON information and uses it to create new Entity objects. This method takes one entity at a time, and when the entity has been fully instantiated locally it causes the skai object to dispatch one of four events - "formReceived", "propertyReceived", "relationshipReceived" and "entityReceived".</p>
    <p>The LocalIndex is able to index these objects because it's just listening for these events and then indexing the associated entities as they come in. There's no reason, by the way, that you couldn't write the following code:
    
    <pre>skai.on("entityReceived", function(entity) { // do something here with this entity }); </pre>
    </p>
  </div>
  <div id="localOperations" class="content">
    <h2>Local Operations</h2>
    <p>So now that we know how the remote services work and we understand how indexing works, let's look at the local methods exposed by the skai object. These are going to be very simple:</p>
    <ul>
      <li>
        <pre>skai.listLocalNodes()</pre>
        - returns an array containing an index object for each node stored in the local index. An index object has two properties: name and guid. </li>
      <li>
        <pre>skai.getAllLocalNodes()</pre>
        - immediately returns an array of all local nodes, fully represented as Entity objects.</li>
      <li>
        <pre>skai.listLocalForms()</pre>
        - returns an array containing an index object for each form stored in the local index. An index object has two properties: name and guid.</li>
      <li>
        <pre>skai.getAllLocalForms()</pre>
        - immediately returns an array of all local forms, fully represented as Entity objects.</li>
      <li>
        <pre>skai.getLocalNodeByName(name)</pre>
        - immediately returns the node with the given name. If more than one node has been indexed with the same name then it will return the most recent. Use getLocalNodeByGuid() for disambiguation.</li>
      <li>
        <pre>skai.getLocalNodeByGuid(guid)</pre>
        - immediately returns the node with the given guid.</li>
      <li>
        <pre>skai.getLocalFormByName(name)</pre>
        - immediately returns the form with the given name. If more than one form has been indexed with the same name then it will return the most recent. use getLocalFormByGuid() for disambiguation.</li>
      <li>
        <pre>skai.getLocalFormByGuid(guid)</pre>
        - immediately returns the form with the given guid.</li>
    </ul>
    <p>This should be enough to allow you to work with any of the data you've pulled from the server. Eventually we will add support for parameterized local queries ("give me all nodes that are friends with Joe Smith") but that's not in place at this time.</p>
  </div>
  <div id="objectManipulation" class="content">
    <h2>Object Manipulation</h2>
    <p>The last missing piece is interaction with entities. Right now this is very, very simple. Each entity has a property called "publicProperties", which is just a list of strings representing the names of properties on that object which are controlled via Skai. If you want to iterate over all Skai-controlled properties, for instance, you'd do something like this:</p>
    <pre>var myEntity = skai.getLocalNodeByName(&quot;foo&quot;);
for (var key in myEntity.localProperties) {
 console.log(&quot;The '&quot; + key + &quot;' property in the &quot; + myEntity.name + &quot; entity has &quot; + myEntity[key].length + &quot; values.&quot;);
}

</pre>
    <p>Because this is javascript, entity objects can have all manner of arbitrary properties which are NOT controlled by Skai - for instance, using the D3 visualizer each entity gets "x" and "y" values. I am free to interact with these as long as there aren't also Skai properties called "x" and "y", which would cause confusion.</p>
    <p>When interacting with Skai properties there are a few things to keep in mind:</p>
    <ul>
      <li>Every property is a collection. Even if it only has one value, it will always be a collection. Get used to typing myProperty[0].</li>
      <li>If you try to set a property equal to a non-collection value then it will simply be wrapped in a collection.</li>
    </ul>
    <p>When interacting with a property you may treat it as a normal javascript array, just be aware that the following operations are generating deltas. It's a good idea to use
    
    <pre>skai.commit(myEntity)</pre>
    after performing any of the following operations:
    </p>
    <ul>
      <li>
        <pre>myEntity.myProperty = "foo"</pre>
        - the value of "myEntity.myProperty" is now ["foo"], and a "SET" delta has been created.</li>
      <li>
        <pre>myEntity.myProperty.push("foo")</pre>
        - "foo" is added to the end of the current value of "myEntity.myProperty", and an "INSERT" delta is created.</li>
      <li>
        <pre>myEntity.myProperty.unshift("foo")</pre>
        - "foo" is added to the beginning of the current value of "myEntity.myProperty" and an "INSERT" delta is created.</li>
      <li>
        <pre>myEntity.pop()</pre>
        - this returns the last value of "myEntity.myProperty" and removes it from the array. A "REMOVE" delta is created.</li>
      <li>
        <pre>myEntity.shift()</pre>
        - this returns the first value of "myEntity.myProperty" and removes it from the array. A "REMOVE" delta is created.</li>
      <li>
        <pre>myEntity.splice(index, length)</pre>
        - this returns the items starting at "index" and continuing along "length". They are removed from the array and a "REMOVE" delta is created.</li>
    </ul>
  </div>
  <div id="conclusion" class="content">
    <h2>Conclusion</h2>
    <p>This should be a good introduction to the whole thing. You now know how to set up an instance of the skai library, connect it to a remote platform instance, perform operations against the remote platform, interact with the resulting objects locally, make changes, and commit them back to the remote instance. Everything from here is utility methods and syntactic sugar - and boy do we need some.</p>
    <p>Here are the current limitations of the system:</p>
    <ul>
      <li>Currently everything is GUID-based. This means that if you want to create a Form that does something, you need to pay attention to the output log to see what GUID gets assigned to that form so that you can use it. The localIndex helps here, but only once the form or entity is already loaded locally - if you are firing up a node.js project for the first time, how do you even know what to query?</li>
      <li>If you type skai.query("list all forms") you'll get a nice big JSON object in your log storing all forms available on the platform that you're talking to. You can find the forms you want, copy and paste their guids and then do a skai.getEntities([all the guids here]), but that's obviously kind of a crappy solution.</li>
      <li>While the node.js library sends Deltas up to the server representing changes, currently the server does not send Deltas down - it simply sends entire serialized entities. These then get indexed and overwrite their previous incarnations. This is not optimal, we should ideally get Deltas working in both directions.</li>
      <li>The aforementioned problems with Form creation - it's slow and it doesn't build on existing infrastructure.</li>
    </ul>
    <p>These are all known issues and are being worked on now. Getting parameterized queries working - both locally and remotely - is also a top priority.</p>
  </div>
</div>
</body>
</html>