var util = require("util");
var events = require("events");

exports.HTTPEndpoint = function(targetHost, targetPort) {
	
	var self = this;
	var http = require("http");
	
	var host, port;
	if (targetHost) {
		host = targetHost;
	} else {
		host = "localhost";
	}
	
	if (targetPort) {
		port = targetPort;
	} else {
		port = "8080";
	}
	
	console.log("Establishing a new HTTP Endpoint at " + host + ":" + port);
	
	events.EventEmitter.call(self);
	
	self.query = function(queryString, callback) {
		var options = getOptions(queryString);
		var request = http.request(options, function(response) {
			response.setEncoding("utf8");
			
			var body = "";
			response.on("data", function(output) {
				body += output;	
			});
			
			response.on("end", function() {
				self.emit("queryResult", body);
				if (callback) {
					try {
						body = JSON.parse(body);
					} catch (e) {
						console.log("Tried to parse body, couldn't. Here's result without parsing:");
					}
					
					callback(body);
				}
			});
		});
		
		request.on("error", function(e) {
			throw(e);
		});
		
		request.end(queryString);
	}
	
	self.getEntities = function(guidCollection, callback) {

		var guids = "";
		
		if (guidCollection instanceof Array) {
			for (var i = 0; i < guidCollection.length; i++) {
				var guid = guidCollection[i];
				
				if (guid.indexOf("g\\") == -1) {
					guid = "g\\" + guid;
				}
				
				guids += guid + " ";
			}
		} else {
			guids = guidCollection;
			if (guids.indexOf("g\\") == -1) {
				guids = "g\\" + guids;
			}
		}
		
		console.log("Submitting the following query:");

		var payload = "GET ENTITIES " + guids + " ";
		
		console.log(payload);
		
		var options = getOptions(payload);
		var request = http.request(options, function(response) {
			response.setEncoding("utf8");
			
			var body = "";
			response.on("data", function(output) {
				body += output;	
			});
			
			response.on("end", function() {
				if (callback) {
					callback(JSON.parse(body));
				}
			});
		});
		
		request.on("error", function(e) { 
			throw(e);
		});
		
		request.end(payload);
	}
	
	self.getEntityProperty = function(entityGuid, propertyName, callback) {
		
	}
	
	self.getAllInstancesOfForm = function(guid, callback) {

		if (guid.indexOf("g\\") == -1) {
			guid = "g\\" + guid;
		}
		
		var payload = "list all entities of type " + guid;
		var options = getOptions(payload);
		var request = http.request(options, function(response) {
			console.log("response received...")
			response.setEncoding("utf8");
			var body = "";
			response.on("data", function(output) {
				body += output;
			});
			
			response.on("end", function(){
				
				// this is here as a workaround of a bug on the server. remove eventually.
				body = body.replace(/\\/, "\\\\");
				
				var output;
				try {
					output = JSON.parse(body);
				} catch(e) {
					output = body;
				}
				
				if (callback) {
					callback(output);
				}
			});
		});
		
		request.on("error", function(e) {
			throw(e);
		});
		
		console.log("Submitting the following to the server:" );
		console.log(payload);
		request.end(payload);
	}
	
	self.deleteEntity = function(guid, callback) {
		
		if (guid.indexOf("g\\") == -1) {
			guid = "g\\" + guid;
		}
		
		var payload = "DELETE ENTITY " + guid;
		var options = getOptions(payload);
		var request = http.require(options, function(response) {
			response.setEncoding("utf8");
			var body = "";
			response.on("data", function(output) {
				body += output;
			});
			
			response.on("end", function() {
				if (callback) {
					callback(JSON.parse(body));
				}
			})
		});
		
		request.on("error", function(e) { 
			throw(e);
		});
		
		request.end(payload);
	}
	
	self.createForm = function(name, propertyList, callback) {
		var payload = "CREATE FORM " + name + " { " + listProps(propertyList) + "}";
		var options = getOptions(payload);
		var request = http.request(options, function(response) {
			response.setEncoding("utf8");
			var body = "";
			response.on("data", function(output) {
				body += output;
			});
			
			response.on("end", function() {
				if (callback) { 
					callback(JSON.parse(body)) 
				};
			})
		});
		
		request.on("error", function(e) {
			throw(e);
		});
		
		request.end(payload);
	};
	
	self.createEntity = function(name, formGuid, callback) {
		
		if (formGuid.indexOf("g\\") == -1) {
			formGuid = "g\\" + formGuid;
		}
		
		var payload = "INSTANTIATE ENTITY " + name + " FROM FORM " + formGuid;
		var options = getOptions(payload);
		var request = http.request(options, function(response) {
			response.setEncoding("utf8");
			
			var body = "";
			response.on("data", function(output) {
				body += output;
			});
			
			response.on("end", function() {
				if (callback) {
					callback(JSON.parse(body));
				}
			});
		});
		
		request.on("error", function(e) {
			throw(e);
		});
		
		request.end(payload);
		
	}
	
	self.commitEntity = function(entity, callback) {
		return self.commitDeltaStream(entity.getDeltas(), callback);
	}
	
	self.commitDeltaStream = function(deltas, callback) {
		var payload = parseDeltas(deltas);
		
		if (payload == null) {
			return;
		}
		
		var options = getOptions(payload);
		var request = http.request(options, function(response) {
			response.setEncoding("utf8");
			var body = "";
			
			response.on("data", function(output) {
				body += output;
			});
			
			response.on("end", function() {
				if(callback) {
					callback(JSON.parse(body));
				}
			})
		})
		
		request.on("error", function(e) {
			throw(e);
		});
		
		console.log("Commiting the following stream of Delta objects: \n" + payload)
		
		request.end(payload);
	};
	
	self.replicateEntities = function(guids, targetHost, targetPort, callback) {
		var payload = "REPLICATE ENTITIES " + guids.join(" ") + " TO " + targetHost + ":" + targetPort;
		var options = getOptions(payload);
		var request = http.request(options, function(response) {
			var body = "";
			response.on("data", function(output) {
				body += output;
			});
			
			response.on("end", function() {
				if (callback) {
					callback(JSON.parse(body));
				}
			});
		});
		
		request.on("error", function(e) {
			throw(e);
		});
		
		console.log("Replicating a stream of entities to " + targetHost + ":" + targetPort);
		request.end(payload);

	}
	
	function getOptions(payload) {
		return {
			host: host,
			port: port,
			method: "POST",
			path: "/api/dsl-experimental",
			headers: {
				"Content-Length": payload.length
			}
		}
	}
	
	function parseDeltas(deltas) {
		if (deltas == null || deltas.length == 0) {
			return null;
		}
		
		var entityGuid = deltas[0].entityGuid;
		
		if (entityGuid.indexOf("g\\") == -1) {
			entityGuid = "g\\" + entityGuid;
		}
		
		var retVal = "UPDATE ENTITY " + entityGuid + " WITH DELTAS ";
		for (var key in deltas) {
			var delta = deltas[key];
			retVal += delta.getFormattedValue();
		} 
		
		return retVal;
	}
	
	function getValues(collection) {
		var retVal = "";
		for (var key in collection) {
			retVal += collection[key] + " ";
		}
	}
	
	function listProps(propertyList) {
		var list = "";
		for (var key in propertyList) {
			list += "COLLECTION " + propertyList[key] + " ";
		}
		
		return list;
	}
}

util.inherits(exports.HTTPEndpoint, events.EventEmitter);