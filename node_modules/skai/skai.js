var util = require("util");
var events = require("events");
var LocalIndex = require("./LocalIndex").LocalIndex;
var Endpoint = require("./Endpoints").HTTPEndpoint;
var propertyCollection = require("./PropertyCollection");
var PropertyCollection = propertyCollection.PropertyCollection;

function Delta(entityGuid, propertyName, values, type) {
	var self = this;
	self.entityGuid = entityGuid;
	self.propertyName = propertyName;
	self.values = values;
	self.deltaType = type;
	
	self.getFormattedValue = function() {
		if (self.values.length > 0 ) {
			return "{ PROPERTY " + self.propertyName + " TYPE " + self.deltaType + " VALUES " + self.values.join(" ") + " } ";
		} else {
			return "{ PROPERTY " + self.propertyName + " TYPE " + self.deltaType + " VALUES null }";
		}
		
	}
}

function Entity(name, guid, timestamp, formGuid, propertyNames) {
	'use strict'
	var self = this;
	var __properties__ = {};
	self.name = name;
	self.guid = guid;
	self.timestamp = timestamp;
	self.formGuid = formGuid;
	self.deltas = [];
	
	
	for (var key in propertyNames) {
		var prop = propertyNames[key];
		registerProperty(prop);
	}
	
	function registerProperty(name) {
		var collection = new PropertyCollection(name, self.guid);
		__properties__[name] = collection;
		
		self.__defineGetter__(name, function() {
			return __properties__[name];
		});
		
		self.__defineSetter__(name, function(v) {
			var value = __properties__[name];
			
			while (value.length > 0) {
				value._pop();
			}
			
			var setValue = [];
			
			if (v instanceof Array) {
				for (var i = 0; i < v.length; i++) {
					setValue.push(v[i]);
					value._push(v[i]);
				}
			} else if (v == null) {
				setValue = null;
			} else {
				value._push(v);
				setValue.push(v);
			}
			
			value.deltas.push(new Delta(self.guid, name, setValue, "SET"))
		});
	}
	
	self.seeProperties = function() { return __properties__; }
	
 	self.getDeltas = function() {
		
		for (var key in __properties__) {
			var property = __properties__[key];
			while (property.deltas.length > 0) {
				self.deltas.push(property.deltas.shift());
			}
		}
		
		return self.deltas;
	}
	
	self.acceptDeltas = function(deltas) {
		
	}
}

exports.Skai = function (endpoint) {
	var self = this;
	events.EventEmitter.call(self);

	propertyCollection.setEntity(Entity);
	propertyCollection.setDelta(Delta);

		
	var localIndex = new LocalIndex(self);
	
	self.listLocalNodes = function() {
		return localIndex.listLocalNodes();
	}
	
	self.listLocalForms = function() {
		return localIndex.listLocalForms();
	}
	
	self.getLocalNodeByName = function(name) {
		return localIndex.getNodeByName(name);
	}	
	
	self.getLocalNodeByGuid = function(guid) {
		return localIndex.getNodeByGuid(guid);
	}
	
	self.getLocalFormByName = function(name) {
		return localIndex.getFormByName(name);
	}
	
	self.getLocalFormByGuid = function(guid) {
		return localIndex.getFormByGuid(guid);
	}
	
	self.getAllLocalNodes = function() {
		return localIndex.getAllNodes()
	}
	
	self.getAllLocalForms = function() {
		return localIndex.getAllForms();
	}
	
	/**
	*	The following two methods are just convenience accessors for properties of locally index entities.
	*/
	self.getLocalValue = function(entityName, propertyName) {
		try {
			return localIndex.getValue(entityName, propertyName);
		} catch (e) {
			console.log(e);
			return null;
		}
	}
	
	self.setLocalValue = function(entityName, propertyName, value) {
		try {
			localIndex.setValue(entityName, propertyName, value);
		} catch (e) {
			console.log(e);
		}
	}
	
	// the endpoint will fire the "entityUpdated" event whenever it's notified
	// of a change, whether that change is a result of a local action or a remote action.
	endpoint.on("entityUpdated", function(result) {
		// result is a collection of "delta" objects. Or is it?
		// TODO persist changes to LocalIndex.
		self.emit("entityUpdated", result);
	});
	
	// utility object with some default query strings
	self.queries = {
		LIST_ALL_FORMS: "list all forms",
		LIST_ALL_PROPERTIES: "list all properties"
	};
	
	self.query = function(queryString, callback) {
		endpoint.query(queryString, function(result) {
			console.log(result);
			self.emit("queryResult", result);
			if (callback) {
				callback(result);
			}
		})
	}
	
	self.getEntities = function(guidCollection, callback) {
		endpoint.getEntities(guidCollection, function(output) {
			
			var result = [];
			
			if (output instanceof Array) {
				for (var i = 0; i < output.length; i++) {
					result.push( processEntity(output[i]) );
				}
			} else {
				var entity = processEntity(output);
				result.push(entity);
			}
			
			console.log(result);

			if (callback) {
				callback(result);
			}
		});
	}
	
	function processEntity(res) {
		
		console.log("PROCESSING ENTITY: ");
		console.log(res);
		
		var props = [];
		for (var key in res.properties) {
			props.push(res.properties[key].name)
		}
		
		var entity = new Entity(res.name, res.guid, res.Timestamp, res.FormGuid, props);
		var broadcastMessage = "";
		
		if (res.EntityType == "form") {
			entity.isForm = true;
			broadcastMessage = "formReceived";
			console.log("Form received...");
		}
		
		if (res.EntityType == "property") {
			entity.isProperty = true;
			broadcastMessage = "propertyReceived";
			console.log("Property received...");
		}
		
		if (res.EntityType == "relationship") {
			entity.isRelationship = true;
			broadcastMessage = "relationshipReceived"
			console.log("Relationship received...");
		}
		
		if (res.EntityType == "entity") {
			broadcastMessage = "entityReceived"
			console.log("Entity received...");
		}
		
		for (var key in res.properties) {
			var property = res.properties[key];
			entity[property.name].setQuietly(property.value); 
		}
		
		self.emit(broadcastMessage, entity);
		
		return entity;
	}
	
	self.getEntityProperty = function(entityGuid, propertyName, callback) {
		endpoint.getEntityProperty(entityGuid, propertyName, function(result) {
			console.log(result);
			if (callback) {
				callback(result);
			}
		});
	}
	
	self.getAllInstancesOfForm = function(formGuid, callback) {
		endpoint.getAllInstancesOfForm(formGuid, function(result) {
			var output = [];
			
			for (var i = 0; i < result.value.length; i++) {
				var node = result.value[i];
				output.push( processEntity(node) );
			}
			
			if(callback) {
				callback(output);
			}
		})
	}
	
	self.delete = function(entityGuid, callback) {
		endpoint.deleteEntity(entityGuid, function(result) {
			self.emit("entityRemoved", entityGuid);
			console.log(result);
			if (callback) {
				callback(result);
			}
		});
	}
	
	self.createForm = function(name, propertyList, callback) {
		
		var reservedProperties = ["guid", "timestamp", "name", "__skai__"];
		
		// potentially iterate through propertNames and flag reserved strings?
		for (var key in propertyList) {
			var n = propertyList[key];
			if (reservedProperties.indexOf(n) > -1) {
				throw("Sorry, you can't have a property named [" + n + "].")
			}
		}
		
		console.log("Attempting to create a form with the name: " + name);
		
		endpoint.createForm(name, propertyList, function(result) {
			self.emit("formCreated", result);
			console.log("Form created: " + result.guid);
			if (callback) { 
				callback(result); 
			}
		});
	}
	
	self.createEntity = function(name, formGuid, callback) {
		endpoint.createEntity(name, formGuid, function(result) {
			
			console.log("Entity Created, here's the response:\n\n" + result);
			
			var res;
			
			if (result instanceof Array) {
				res = result[0]; // hacky but this should only ever return a collection of length 1.
			} else {
				res = result;
			}
			
			
			var props = [];
			for (var key in res.properties) {
				props.push(res.properties[key].name)
			}
			
			var entity = new Entity(res.name, res.guid, res.Timestamp, res.FormGuid, props);
			
			self.emit("entityCreated", entity);
			
			if (callback) {
				callback(entity);
			}
		
		});
	}
	
	
	self.commitEntity = function(entity, callback) {
		endpoint.commitEntity(entity, function(result) {
			console.log(result);
			self.emit("entityCommited", result);
			entity.deltas = [];
			
			if (callback) {
				
				callback(result);
			}
		});
	}
	
	
// stubbed out Extend stuff, probably not working.
	self.exposeQueryAtURL = function(query, url, callback) {
		endpoint.exposeQueryAtURL(query, url, function(result) {
			console.log(result);
			self.emit("queryExposedAtURL", result);
			
			if (callback) {
				callback(result);
			}
		});
	}
	
	self.replicateEntities = function(guids, targetHost, targetPort, callback) {
		endpoint.replicateEntities(guids, targetHost, targetPort, function(result) {
			console.log(result);
			if (callback) {
				callback(result);
			}
		});
	}
	
	self.getDataFromURL = function(url, callback) {
		endpoint.getDataFromURL(url, function(result) {
			console.log(result);
			if (callback) {
				callback(result);
			}
			
		});
	}
	
	self.listPendingImports = function(callback) {
		endpoint.listPendingImports(function(result) {
			console.log(result);
			if (callback) {
				callback(result);
			}
		})
	}
	
	self.acceptPendingImport = function(guid, callback) {
		endpoint.acceptPendingImport(guid, function(result) {
			console.log(result);
			if (callback) {
				callback(result);
			}
		})
	}
	
	self.rejectPendingImport = function(guid, callback) {
		endpoint.rejectPendingImport(guid, function(result) {
			console.log(result);
			if (callback) {
				callback(result);
			}
		});
	}
}

util.inherits(exports.Skai, events.EventEmitter);

/** this returns an instantiated "skai" instance, ready for use. **/
exports.Begin = function(host, port) {
	return new exports.Skai(new Endpoint(host, port));
}